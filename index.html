<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Froot ‚Äî Breath-Synced Loop Tone (Single-File)</title>
<style>
  :root{
    --bg:#0f1222;
    --card:#161a31;
    --ink:#e9ecff;
    --muted:#99a1c7;
    --accent:#7aa2ff;

    /* Breath phase colors */
    --breath-in:#2ecc71;   /* green */
    --breath-hold:#f1c40f; /* yellow */
    --breath-out:#e74c3c;  /* red/orange */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 700px at 20% -10%, #1d2344 0%, var(--bg) 58%  ), radial-gradient(800px 600px at 120% 120%, #1a1f3c 0%, var(--bg) 60%);
    color:var(--ink); font:500 16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    display:flex; align-items:center; justify-content:center; padding:28px;
  }
  .wrap{width:clamp(320px, 92vw, 980px)}
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.08));
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px; padding:18px 18px 22px; box-shadow:0 10px 40px rgba(0,0,0,.35);
  }
  h1{margin:0 0 8px; font-size:20px; letter-spacing:.3px}
  .sub{color:var(--muted); margin-bottom:14px}
  .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
  .modebadge{
    display:inline-flex; align-items:center; gap:8px;
    background:rgba(122,162,255,.12); color:#cfe0ff; border:1px solid rgba(122,162,255,.25);
    padding:8px 10px; border-radius:10px; font-weight:600; font-size:14px; user-select:none;
  }
  #varGroup{display:none}

  .panel{
    margin-top:14px; display:grid; grid-template-columns: 1fr 320px; gap:14px;
  }
  @media (max-width:880px){ .panel{grid-template-columns:1fr} }

  /* ===== Ball ===== */
  .ballWrap{display:flex; align-items:center; justify-content:center; padding:18px}
  #breathBall{
    position:relative; width:min(58vw, 360px); height:min(58vw, 360px); min-width:220px; min-height:220px;
    border-radius:50%; cursor:pointer; user-select:none;
    background:
      radial-gradient(120% 120% at 30% 25%, rgba(255,255,255,.35), rgba(255,255,255,.06) 42%, rgba(255,255,255,0) 60%),
      radial-gradient(100% 100% at 70% 70%, rgba(122,162,255,.3), rgba(122,162,255,.05) 50%, rgba(122,162,255,0) 70%),
      linear-gradient(160deg, #2d355e 0%, #1f2445 60%, #181d3a 100%);
    box-shadow:
      inset 0 0 60px rgba(122,162,255,.14),
      0 18px 45px rgba(0,0,0,.40),
      0 2px 0 1px rgba(255,255,255,.06) inset;
    transition: transform .20s ease, box-shadow .25s ease;
    outline:none;
  }
  #breathBall:hover{ transform: translateY(-1px) scale(1.01); }
  #breathBall.playing{ transform: translateY(-2px) scale(1.02); }
  /* Optional gentle tint on the ball by phase */
  #breathBall.phase-in   { box-shadow: inset 0 0 60px rgba(46,204,113,.35), 0 18px 45px rgba(0,0,0,.40), 0 2px 0 1px rgba(255,255,255,.06) inset; }
  #breathBall.phase-hold { box-shadow: inset 0 0 60px rgba(241,196,15,.35), 0 18px 45px rgba(0,0,0,.40), 0 2px 0 1px rgba(255,255,255,.06) inset; }
  #breathBall.phase-out  { box-shadow: inset 0 0 60px rgba(231,76,60,.35), 0 18px 45px rgba(0,0,0,.40), 0 2px 0 1px rgba(255,255,255,.06) inset; }

  /* ===== Breath Phase HUD (label + sweeping arc + edge flash) ===== */
  .phaseHUD{ position:absolute; inset:8%; border-radius:50%; pointer-events:none; }
  .phaseHUD .phaseArc{ position:absolute; inset:-6px; border-radius:50%;
    background: conic-gradient(var(--phase-color, #22d) 0deg var(--arc, 0deg), transparent var(--arc, 0deg) 360deg);
    filter: drop-shadow(0 2px 8px rgba(0,0,0,.18));
  }
  .phaseHUD .phaseEdge{ position:absolute; inset:-6px; border-radius:50%; box-shadow:0 0 0 0 rgba(255,255,255,0); }
  .phaseHUD .phaseLabel{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size: clamp(26px, 6.2vw, 48px);
    letter-spacing:.10em; text-shadow:0 1px 2px rgba(0,0,0,.18); mix-blend-mode:hard-light; font-variant-caps:all-small-caps;
  }
  .phaseHUD .subtext{
    position:absolute; left:0; right:0; bottom:12%; text-align:center; font-size:12px; color:rgba(255,255,255,.7)
  }
  .phaseHUD .phaseEdge.flash{ animation: edgeFlash 180ms ease-out; }
  @keyframes edgeFlash{ from{ box-shadow:0 0 0 14px rgba(255,255,255,.92);} to{ box-shadow:0 0 0 0 rgba(255,255,255,0);} }
  .phase-in   .phaseHUD{ --phase-color: var(--breath-in); }
  .phase-hold .phaseHUD{ --phase-color: var(--breath-hold); }
  .phase-out  .phaseHUD{ --phase-color: var(--breath-out); }
  .phase-in   .phaseLabel{ color: var(--breath-in); }
  .phase-hold .phaseLabel{ color: var(--breath-hold); }
  .phase-out  .phaseLabel{ color: var(--breath-out); }

  /* ===== Right-side controls ===== */
  .panelR{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.05)); border:1px solid rgba(255,255,255,.08);
    border-radius:12px; padding:12px}
  .ctl{margin:6px 0 12px}
  .ctl label{display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:13px; margin-bottom:6px}
  input[type="range"]{width:100%}
  .caps{font-variant-caps:all-small-caps; letter-spacing:.06em}
  .mini{font-size:12px; color:var(--muted)}
  .btn{
    display:inline-flex; align-items:center; gap:8px; border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.05); padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:700; color:#fff; text-decoration:none;
  }
  .btn:active{ transform: translateY(1px) }
  .hint{color:var(--muted); font-size:12px; margin-top:8px}
  .row .modebadge input[type="checkbox"]{ transform: translateY(1px) }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Practice Rhythm</h1>
      <div class="sub">Tap the orb to start/stop. With <b>Loop</b> on, tone sustains and the orb shows clear phase changes: <b>IN ‚Üí HOLD ‚Üí OUT</b>.</div>

      <div class="row" style="gap:8px 10px;margin-bottom:8px">
        <span id="modeBadge" class="modebadge">üéØ Mode: Signal</span>
        <div id="varGroup" class="modebadge" style="display:none"> ‚Ä¶ </div>

        <!-- Loop toggle -->
        <label class="modebadge" style="cursor:pointer">
          <input id="loopToggle" type="checkbox" onchange="setLoop(this.checked)" style="margin-right:8px">
          üîÅ Loop tone (hands-free)
        </label>

        <!-- Loop auto‚Äëstop -->
        <label class="modebadge" style="cursor:pointer">
          ‚è±Ô∏è Auto‚Äëstop:
          <select id="loopTimer" onchange="setLoopTimer(this.value)" style="margin-left:6px">
            <option value="0">Off</option>
            <option value="5">5m</option>
            <option value="10">10m</option>
            <option value="20" selected>20m</option>
            <option value="30">30m</option>
            <option value="45">45m</option>
            <option value="60">60m</option>
          </select>
          <span id="loopCountdown" style="margin-left:8px; opacity:.85"></span>
        </label>
      </div>

      <div class="panel">
        <!-- Left: Orb -->
        <div class="ballWrap">
          <div id="breathBall" tabindex="0" aria-label="Breathing Orb (tap to play/pause)"></div>
        </div>

        <!-- Right: Controls -->
        <div class="panelR">
          <div class="ctl">
            <label class="caps">Frequency <span><strong id="freqLabel">440</strong> Hz</span></label>
            <input id="freq" type="range" min="110" max="880" step="1" value="440" oninput="updateFreqLabel()">
          </div>

          <div class="ctl" style="margin-top:16px">
            <div class="caps" style="margin-bottom:6px">Breath Pattern</div>
            <div class="row" style="gap:6px; flex-wrap:wrap">
              <button class="btn" onclick="setPatternPreset(4,7,8)">üå¨Ô∏è 4‚Äì7‚Äì8</button>
              <button class="btn" onclick="setPatternPreset(4,4,4)">‚öñÔ∏è Box 4‚Äì4‚Äì4</button>
              <button class="btn" onclick="setPatternPreset(5,5,5)">üü© 5‚Äì5‚Äì5</button>
              <button class="btn" onclick="setPatternPreset(6,2,8)">üåä 6‚Äì2‚Äì8</button>
            </div>
            <div class="mini hint">Phase ring resets each phase; a brief edge flash + tiny haptic marks the exact switch.</div>
          </div>

          <div class="ctl" style="margin-top:10px">
            <div class="caps" style="margin-bottom:6px">Quick Actions</div>
            <div class="row" style="gap:8px; flex-wrap:wrap">
              <button class="btn" onclick="togglePlay()"><span id="playIcon">‚ñ∂Ô∏è</span> <span id="playText">Play</span></button>
              <button class="btn" onclick="stopTone()">‚èπÔ∏è Stop</button>
            </div>
          </div>

          <div class="hint">Tip: enable <b>Loop</b> for hands‚Äëfree practice; the tone ‚Äúbreathes‚Äù gently and stays in the background.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden audio element (optional pipe for some browsers/background) -->
  <audio id="bgPipe" preload="auto" style="display:none"></audio>

<script>
/* ============================================================
   Minimal audio engine with breath‚Äësynced LFO + loop + HUD
   Single-file; no external assets.
   ============================================================ */
let ctx=null, master=null, comp=null;
let toneOsc=null, toneGain=null;
let lfoOsc=null, lfoGain=null;
let pipeDest=null, pipeOsc=null, pipeGain=null; // optional background pipe
let retriggerGuard=false, activePlaying=false;

let loopMode=false;
let loopTimerMin=20, loopTimerId=null, loopStopDeadline=0, loopCountdownTick=0;

/* ------------------ Utilities ------------------ */
function $(q, root){ return (root||document).querySelector(q); }
function updateFreqLabel(){ $('#freqLabel').textContent = $('#freq').value; }
function getNow(){ return ctx ? ctx.currentTime : 0; }
function ensureCtx(){
  if(ctx) return;
  ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
  master = ctx.createGain();
  // Gentle master level
  master.gain.value = 0.9;

  // Mild compressor to tame edges
  comp = ctx.createDynamicsCompressor();
  comp.threshold.value = -18; comp.knee.value = 22; comp.ratio.value = 3.0; comp.attack.value = 0.006; comp.release.value = 0.22;
  master.connect(comp); comp.connect(ctx.destination);

  // Optional pipe for <audio> element (helps some mobile browsers keep "audio session" active)
  pipeDest = ctx.createMediaStreamDestination();
  const bg = $('#bgPipe');
  try { bg.srcObject = pipeDest.stream; } catch(_){}
}
function resumeCtx(){ if(ctx && ctx.state==='suspended'){ ctx.resume().catch(()=>{}); } }

/* ------------------ Loop persistence ------------------ */
function setLoop(on){
  loopMode = !!on;
  try{ localStorage.setItem("froot_loop_v1", JSON.stringify({on:loopMode})) }catch(e){}
  // If enabling while playing, restart as sustained loop
  if(loopMode && activePlaying){ stopTone(); setTimeout(()=>{ playTone(); }, 120); }
  resetLoopCountdown();
}
try{
  const lp = JSON.parse(localStorage.getItem("froot_loop_v1")||"{}");
  if(lp.on){ const box = $('#loopToggle'); if(box){ box.checked = true; } loopMode = true; }
}catch(_){}

/* ------------------ Loop auto-stop timer ------------------ */
function setLoopTimer(minStr){
  loopTimerMin = parseInt(minStr,10) || 0;
  try{ localStorage.setItem('froot_loop_timer_v1', String(loopTimerMin)); }catch(_){}
  resetLoopCountdown();
}
function resetLoopCountdown(){
  if(loopTimerId){ clearTimeout(loopTimerId); loopTimerId=null; }
  if(loopCountdownTick){ clearInterval(loopCountdownTick); loopCountdownTick=0; }
  const cd = $('#loopCountdown'); if(cd) cd.textContent='';
  if(loopMode && activePlaying && loopTimerMin>0){
    const ms = loopTimerMin*60000;
    loopStopDeadline = Date.now()+ms;
    loopTimerId = setTimeout(()=>{ stopTone(); }, ms);
    loopCountdownTick = setInterval(()=>{
      const left = Math.max(0, loopStopDeadline - Date.now());
      const m = Math.floor(left/60000), s = Math.floor((left%60000)/1000);
      if(cd){ cd.textContent = (m>0? (m+'m ') : '') + (s+'s left'); }
      if(left<=0){ clearInterval(loopCountdownTick); loopCountdownTick=0; if(cd){ cd.textContent=''; } }
    }, 1000);
  } else {
    loopStopDeadline = 0;
  }
}
// Restore timer on load
document.addEventListener('DOMContentLoaded', ()=>{
  let tmin = parseInt(localStorage.getItem('froot_loop_timer_v1')||'20',10);
  if(!isNaN(tmin)){ const sel=$('#loopTimer'); if(sel){ sel.value=String(tmin); } loopTimerMin=tmin; }
});

/* ------------------ Breath Phase HUD ------------------ */
const breathUI = (function(){
  let hud, arc, edge, label, subtext, raf = 0, t0 = 0, dur = 1000, ball;
  function attach(){
    ball = $('#breathBall') || document.querySelector('#ball, #orb, .ball, .orb, .dot, .circle');
    if(!ball) return;
    if(ball.querySelector('.phaseHUD')){
      hud = ball.querySelector('.phaseHUD');
      arc = hud.querySelector('.phaseArc'); edge = hud.querySelector('.phaseEdge'); label = hud.querySelector('.phaseLabel'); subtext = hud.querySelector('.subtext');
      return;
    }
    ball.insertAdjacentHTML('beforeend',
      '<div class="phaseHUD">'+
        '<div class="phaseArc" style="--arc:0deg"></div>'+
        '<div class="phaseEdge"></div>'+
        '<div class="phaseLabel">READY</div>'+
        '<div class="subtext">tap to start</div>'+
      '</div>'
    );
    hud = ball.querySelector('.phaseHUD'); arc = hud.querySelector('.phaseArc');
    edge = hud.querySelector('.phaseEdge'); label = hud.querySelector('.phaseLabel'); subtext = hud.querySelector('.subtext');
  }
  function progressLoop(now){
    const p = Math.min(1, (now - t0)/dur);
    arc.style.setProperty('--arc', (p*360)+'deg');
    if(p < 1) { raf = requestAnimationFrame(progressLoop); }
  }
  function flashEdge(){ edge.classList.remove('flash'); void edge.offsetWidth; edge.classList.add('flash'); }
  function vibrate(ms){ try{ if(navigator.vibrate) navigator.vibrate(ms||12); }catch(_){ } }
  function setPhase(name, ms){
    if(!hud){ attach(); } if(!hud) return;
    const ball = $('#breathBall');
    ball.classList.remove('phase-in','phase-hold','phase-out');
    const tag = (name==='hold'?'phase-hold':(name==='out'?'phase-out':'phase-in'));
    ball.classList.add(tag);
    label.textContent = (name==='hold'?'HOLD':(name==='out'?'OUT':'IN'));
    if(subtext){ subtext.textContent = ''; }
    cancelAnimationFrame(raf); t0 = performance.now(); dur = Math.max(200, (ms|0)||1000);
    arc.style.setProperty('--arc','0deg'); raf = requestAnimationFrame(progressLoop);
    flashEdge(); vibrate(10);
  }
  function ready(){ if(!hud){ attach(); } if(!hud) return; label.textContent='READY'; if(subtext){ subtext.textContent='tap to start'; } arc.style.setProperty('--arc','0deg'); }
  return { attach, setPhase, ready };
})();
function setBreathPhaseUI(phaseName, durationMs){ breathUI.setPhase(phaseName, durationMs); }

/* ------------------ Guided-breath driver (IN‚ÜíHOLD‚ÜíOUT) ------------------ */
const breathDriver = (function(){
  let cfg = {in:4000, hold:7000, out:8000}; // default 4-7-8
  let tid = null, running = false, seq = ['in','hold','out'], idx = 0;

  function step(){
    const name = seq[idx]; const ms = cfg[name] || 1000;
    setBreathPhaseUI(name, ms);
    syncLFOToPhase(name, ms); // << synchronize sound dynamics to visual phase
    tid = setTimeout(()=>{ idx = (idx+1) % seq.length; step(); }, ms);
  }
  function start(){ if(running) return; running = true; idx=0; step(); }
  function stop(){ running=false; clearTimeout(tid); tid=null; try{ breathUI.ready(); }catch(_){} }
  function isRunning(){ return running; }
  function setPattern(msIn, msHold, msOut){
    cfg.in=msIn|0; cfg.hold=msHold|0; cfg.out=msOut|0;
    // If running, restart the cycle at IN with new timings
    if(running){ stop(); start(); }
  }
  function getPattern(){ return { ...cfg }; }
  return { start, stop, isRunning, setPattern, getPattern };
})();
function setPatternPreset(pin, phold, pout){
  breathDriver.setPattern(pin*1000, phold*1000, pout*1000);
}

/* ------------------ Breath-synced LFO shaping ------------------ */
function syncLFOToPhase(name, ms){
  if(!ctx || !toneGain || !lfoOsc || !lfoGain) return;
  const now = ctx.currentTime;
  // Target depths: deeper on IN, flat on HOLD, lighter on OUT
  const targetDepth = (name==='in') ? 0.055 : (name==='hold' ? 0.0 : 0.025);
  const baseLevel   = (name==='in') ? 0.20  : (name==='hold' ? 0.18 : 0.16);
  const targetHz    = (name==='in') ? 0.14  : (name==='hold' ? 0.06 : 0.10);

  try{
    // Smooth ramps to avoid clicks
    lfoGain.gain.cancelScheduledValues(now);
    lfoGain.gain.setValueAtTime(lfoGain.gain.value, now);
    lfoGain.gain.linearRampToValueAtTime(targetDepth, now + 0.25);

    lfoOsc.frequency.cancelScheduledValues(now);
    lfoOsc.frequency.setValueAtTime(lfoOsc.frequency.value, now);
    lfoOsc.frequency.linearRampToValueAtTime(targetHz, now + 0.25);

    // Also subtly steer the base sustained level
    toneGain.gain.cancelScheduledValues(now);
    toneGain.gain.setValueAtTime(toneGain.gain.value, now);
    toneGain.gain.linearRampToValueAtTime(baseLevel, now + 0.30);
  }catch(_){}
}

/* ------------------ Tone engine ------------------ */
function playTone(){
  ensureCtx();

  // Stop any current tone first
  const now = getNow();
  if(toneOsc){ killToneFast(now); }

  if(retriggerGuard) return; retriggerGuard = true; setTimeout(()=>{ retriggerGuard=false; }, 250);

  // Build oscillator & gain
  toneOsc  = ctx.createOscillator();
  toneGain = ctx.createGain();

  const freq = parseFloat($('#freq').value)||440;
  toneOsc.type = "sine";
  toneOsc.frequency.setValueAtTime(freq, now);

  // One-shot envelope (LOOP OFF)
  if(!loopMode){
    const atk=0.030, hold=0.25, rel=0.150, peak=0.22, sus=0.16, tail=5.4;
    toneGain.gain.cancelScheduledValues(now);
    toneGain.gain.setValueAtTime(0.0, now);
    toneGain.gain.linearRampToValueAtTime(peak, now + atk);
    toneGain.gain.linearRampToValueAtTime(sus,  now + atk + hold);
    toneGain.gain.setValueAtTime(sus, now + tail);
    toneGain.gain.linearRampToValueAtTime(0.0005, now + tail + rel);

    toneOsc.connect(toneGain); toneGain.connect(master);
    toneOsc.start(now);
    toneOsc.stop(now + tail + rel + 0.02);

    activePlaying = true; pulseOn();
    toneOsc.onended = ()=>{ pulseOff(); activePlaying=false; };

  } else {
    // LOOP ON ‚Üí sustained tone with gentle breathing (LFO), synced to phases
    toneGain.gain.cancelScheduledValues(now);
    toneGain.gain.setValueAtTime(0.0, now);
    toneGain.gain.linearRampToValueAtTime(0.18, now + 0.18); // ~180ms fade

    // LFO
    lfoOsc = ctx.createOscillator();
    lfoGain = ctx.createGain();
    lfoOsc.type = "sine";
    lfoOsc.frequency.setValueAtTime(0.12, now);
    lfoGain.gain.setValueAtTime(0.03, now);

    lfoOsc.connect(lfoGain);
    lfoGain.connect(toneGain.gain);

    toneOsc.connect(toneGain); toneGain.connect(master);
    toneOsc.start(now); lfoOsc.start(now);

    // Start breath driver (will also call syncLFOToPhase)
    try{ breathDriver.start(); }catch(_){}

    activePlaying = true; pulseOn();
  }

  resumeCtx();
  setMediaSessionPlaying(true);
  resetLoopCountdown();
}

function stopTone(){
  if(!ctx){ return; }
  const now = getNow();

  // Fade-out main tone
  killToneFast(now);

  // Clean up LFO if present
  if(lfoOsc || lfoGain){
    try{
      lfoGain.gain.cancelScheduledValues(now);
      lfoGain.gain.setValueAtTime(lfoGain.gain.value, now);
      lfoGain.gain.linearRampToValueAtTime(0.0, now + 0.12);
      lfoOsc.stop(now + 0.14);
    }catch(_){}
    setTimeout(function(){
      try{ lfoOsc.disconnect(); }catch(_){}
      try{ lfoGain.disconnect(); }catch(_){}
      lfoOsc = null; lfoGain = null;
    }, 180);
  }

  // Stop guided breath loop + UI reset
  try{ breathDriver.stop(); }catch(_){}

  // Cancel timer UI
  if(loopTimerId){ clearTimeout(loopTimerId); loopTimerId=null; }
  if(loopCountdownTick){ clearInterval(loopCountdownTick); loopCountdownTick=0; }
  const _cd = $('#loopCountdown'); if(_cd){ _cd.textContent=''; }

  activePlaying = false; pulseOff();
  setMediaSessionPlaying(false);
}
function killToneFast(now){
  try{
    if(toneGain){
      const cur = Math.max(0.0002, toneGain.gain.value);
      toneGain.gain.cancelScheduledValues(now);
      toneGain.gain.setValueAtTime(cur, now);
      toneGain.gain.linearRampToValueAtTime(0.0001, now + 0.12);
    }
    if(toneOsc){
      toneOsc.stop(now + 0.14);
    }
  }catch(_){}
  setTimeout(function(){
    try{ toneOsc && toneOsc.disconnect(); }catch(_){}
    try{ toneGain && toneGain.disconnect(); }catch(_){}
    toneOsc=null; toneGain=null;
  }, 180);
}

/* ------------------ UI helpers ------------------ */
function pulseOn(){ const b=$('#breathBall'); b && b.classList.add('playing'); $('#playIcon').textContent='‚è∏Ô∏è'; $('#playText').textContent='Pause'; }
function pulseOff(){ const b=$('#breathBall'); b && b.classList.remove('playing'); $('#playIcon').textContent='‚ñ∂Ô∏è'; $('#playText').textContent='Play'; }
function togglePlay(){ if(activePlaying){ stopTone(); } else { playTone(); } }

/* ------------------ Media Session (locks/OS controls) ------------------ */
function setMediaSessionPlaying(isPlaying){
  if(!('mediaSession' in navigator)) return;
  try{
    navigator.mediaSession.metadata = new MediaMetadata({
      title: (loopMode?'Froot tone (loop)':'Froot tone'),
      artist:'PLNT Earth', album:'Illumina'
    });
    navigator.mediaSession.playbackState = isPlaying?'playing':'paused';
    navigator.mediaSession.setActionHandler('play', ()=>{ if(!activePlaying) playTone(); });
    navigator.mediaSession.setActionHandler('pause', ()=>{ if(activePlaying) stopTone(); });
    navigator.mediaSession.setActionHandler('stop', ()=>{ if(activePlaying) stopTone(); });
  }catch(_){}
}

/* ------------------ Background pipe (optional) ------------------ */
function startPipe(){
  if(!ctx || !pipeDest) return;
  if(pipeOsc) return;
  // Very low-level subsonic to keep stream alive
  pipeOsc = ctx.createOscillator(); pipeOsc.type='sine'; pipeOsc.frequency.value = 20;
  pipeGain = ctx.createGain(); pipeGain.gain.value = 0.00001; // nearly inaudible
  pipeOsc.connect(pipeGain); pipeGain.connect(pipeDest);
  const bg = $('#bgPipe'); try{ bg.muted=false; bg.play().catch(()=>{}); }catch(_){}
  pipeOsc.start();
}
function stopPipe(){
  if(!ctx) return;
  try{ const bg=$('#bgPipe'); bg.pause(); }catch(_){}
  try{ pipeOsc && pipeOsc.stop(); }catch(_){}
  try{ pipeGain && pipeGain.disconnect(); }catch(_){}
  pipeOsc=null; pipeGain=null;
}

/* ------------------ Wire up interactions ------------------ */
document.addEventListener('DOMContentLoaded', ()=>{
  breathUI.attach();
  updateFreqLabel();

  // Tap/click orb to toggle play
  const ball = $('#breathBall');
  ball.addEventListener('click', togglePlay);
  ball.addEventListener('keydown', (e)=>{ if(e.code==='Space' || e.code==='Enter'){ e.preventDefault(); togglePlay(); } });

  // Auto-start/stop background pipe with loop state
  const loopBox = $('#loopToggle');
  if(loopBox){ loopBox.addEventListener('change', ()=>{ if(loopBox.checked){ startPipe(); } else { stopPipe(); } }); if(loopBox.checked){ startPipe(); } }
});

// Try to keep audio resumed when returning to tab
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible'){ resumeCtx(); } });

/* ------------------ Defaults ------------------ */
setPatternPreset(4,7,8); // 4-7-8 default
</script>
</body>
</html>
